#+STARTUP: latexpreview
#+LATEX_HEADER: \usepackage[hyperref,x11names]{xcolor}
#+LATEX_HEADER: \usepackage[colorlinks=true,urlcolor=SteelBlue4,linkcolor=Firebrick4]{hyperref}
#+LATEX_HEADER: \usepackage{physics}
  #+LATEX_HEADER: \usepackage{hyperref, url}
  #+LATEX_HEADER: \usepackage[square,numbers]{natbib}
  #+LATEX_HEADER: \usepackage{subcaption}
  #+LATEX_HEADER: \usepackage{cases}
  #+LATEX_HEADER: \graphicspath{ {./} }
  #+LATEX_HEADER: \usepackage{tikz}
  #+LATEX_HEADER: \usetikzlibrary{arrows,plotmarks,calc,positioning,fit}
  #+LATEX_HEADER: \usetikzlibrary{shapes.geometric, decorations.pathmorphing, patterns, backgrounds, url}
  #+LATEX_HEADER: \usepackage[square,numbers]{natbib}
  #+LATEX_HEADER: \newcommand{\tikzremember}[1]{{  \tikz[remember picture,overlay]{\node (#1) at (0,11pt) { };}}}
  #+LATEX_HEADER: \tikzset{snake it/.style={decorate, decoration=snake}}
  #+LATEX_HEADER: \usepackage[nottoc]{tocbibind}



* Tasks 
** TODO Finish doing the gamma surfaces for all planes for pure titanium. 
*** DONE Implement Homogenous Shear boundary conditions for gamma surface calculation.
    CLOSED: [2018-11-19 Mon 12:08]
** TODO Look at the range of the bond integrals we have in Titanium graphically. 
*** TODO Plot the bond integrals of tbe with the cutoff and see what happens under different conditions. 
** TODO Python script: remove include statements  -->  One file.  
** TODO Summarise UCL DFT lectures. 
** TODO Write first paragraph of Literature review
*** TODO Summarise Stacking Faults and write review
*** TODO Write up the tight binding fitting of oxygen and an explanation for paramagnetism. 
*** TODO Summarise dislocations and Oxygen interactions (review)
** TODO Write summary of org-mode
** DONE Investigate why rmaxh changes energy
   CLOSED: [2018-11-19 Mon 11:45]
   - Variation of rmaxh does not change the energy
   - Obviously the number of neighbours changes with rmaxh.
   - Conclusion: rmaxh only determines what atoms are its neighbours. 
   - This is the file which investigates this:
     [[file:~/Documents/ti/complete_titanium/ti_01-11-18/mod_rmaxh/check_rmaxh_energy_neighbours.py][check_rmaxh_energy_number_neighbours]]
   - Here is the data:
     [[file:~/Documents/ti/complete_titanium/ti_01-11-18/mod_rmaxh/energy_for_energy_vs_rmaxh.pkl][Energy data for energy vs rmaxh]]
     [[file:~/Documents/ti/complete_titanium/ti_01-11-18/mod_rmaxh/rmaxh_for_energy_or_n_neighbours_vs_rmaxh.pkl][rmaxh data for energy/n_neighbours vs rmaxh]]
     [[file:~/Documents/ti/complete_titanium/ti_01-11-18/mod_rmaxh/n_neighbours_for_n_neighbours_vs_rmaxh.pkl][n_neighbours for n_neighbours vs rmaxh]]
   - The output pictures are this:
   #+CAPTION: Variation of energy with change in rmaxh
   #+NAME:   fig:Energy_vs_rmaxh.png
   [[file:~/Documents/ti/complete_titanium/ti_01-11-18/mod_rmaxh/Energy_vs_rmaxh.png]]
   #+CAPTION: Variation of number of neighbours with change in rmaxh
   #+NAME:   fig:n_neighbours_vs_rmaxh.png
   [[file:~/Documents/ti/complete_titanium/ti_01-11-18/mod_rmaxh/n_neighbours_vs_rmaxh.png]]
   
** DONE Show supercell of BOP working 
   CLOSED: [2018-11-16 Fri 13:38]


* General notes of codes. 

** Pair potentials in tbe code
   - Pair potential is constructed by [[file:~/lm/tb/makvpp.f][makvpp.f]]. 
   - This calls [[file:~/lm/tb/vppder.f][vppder.f]] which actually evaluates the pair potential at that
     point
   - In makvpp.f, if in the range of $r_1 < r < r_{\text{c}}$, then
     augmentative/multiplicative polynomial is used.
     - To make this polynomial [[file:~/lm/tb/pcut45.f][pcut45.f]] is used.
     - Depending on the degree of polynomial we have this structure:
       #+BEGIN_SRC fortran
      rr = r1 - r2
      xr1 = x - r1
      xr2 = x - r2

      c = val*rr*rr
      if (n == 5) then
        pnorm = rr**(-5)
        a = (0.5d0*curv*rr - 3d0*slo)*rr + 6d0*val
        b = (slo*rr - 3d0*val)*rr
      elseif (n == 4) then
        pnorm = rr**(-4)
        a = (0.5d0*curv*rr - 2d0*slo)*rr + 3d0*val
        b = (slo*rr - 2d0*val)*rr
      p2 = pnorm*(c + xr1*(b + xr1*a))
      dp2 = pnorm*(b + xr1*2d0*a)
      ddp2 = pnorm*2d0*a
      e = p2 * xr2**(n-2)
      de = (xr2*dp2 + float(n-2)*p2) * xr2**(n-3)
      dde = (xr2*xr2*ddp2+float(2*(n-2))*xr2*dp2+float((n-2)*(n-3))*p2)
C ... e, de and dde are the values and derivatives of the polynomial in the region r1 , r < rc
       #+END_SRC
     - So the form of the polynomial used is
       - $$ P_5(x) = (x-r_2)^3 P_2(x)  $$
       - \[ P_2(x) = a(x-r1)^2 + b(x-r_1) + c \]
       - \[ a = \frac{1}{ (r1-r2)^5 } \big\{  \frac{1}{2}(r_1-r_2)^2f"(r_1) -3(r_1-r_2)f'(r_1) + 6f(r_1) \big\} \]
       - \[  b = \frac{1}{(r_1-r_2)^4} \big\{ f'(r_1)*(r_1-r_2) - 3f(r_1) \big\}  \]
       - \[ \frac{1}{(r_1 - r_2)^5} x \]
       - \[  c = \frac{ f(r_1) }{ (r_1-r_2)^3} \]
       - Where $f(x)$ is the function that needs to be cut
   - Current model has this
     #+BEGIN_SRC bash
Ti,Ti:
   type 2 (Exp. decay), V(d) = a exp (- b d)
             sss    sps    pps    ppp    sds    pds    pdp    dds    ddp    ddd
   coeff:   0.00   0.00   0.00   0.00   0.00   0.00   0.00  -2.75   1.84  -0.46
   decay:   0.00   0.00   0.00   0.00   0.00   0.00   0.00   0.71   0.71   0.71
   cutoff type 2 (multiplicative), 5th order polynomial, range [r1, rc]
             sss    sps    pps    ppp    sds    pds    pdp    dds    ddp    ddd
   r1:      0.00   0.00   0.00   0.00   0.00   0.00   0.00   6.20   6.20   6.20
   rc:      0.00   0.00   0.00   0.00   0.00   0.00   0.00   8.50   8.50   8.
     
     #+END_SRC
   - So bond integrals look like 
     #+BEGIN_SRC python
import numpy as np 
import matplotlib.pyplot as plt
rc('font', **{'family':'serif','serif':['Palatino'],  'size'   : 18})
rc('text', usetex=True)
import pickle

def bond_integral(A, b, d):
    f = A * np.exp( - b * d )
    df =  - b * f
    ddf = - b * df
    return f, df, ddf

def poly(x, deg, r1, r2, f, df, ddf ):
    rr = r1 - rc
    xr1 = x - r1
    xr2 = x - r2
    c = val*rr*rr
    if (deg== 5):
        pnorm = rr**(-5)
        a = (0.5 * ddf * rr - 3. * df ) * rr   +   6. * val
        b = (df * rr - 3. * val) * rr
    elif deg == 4:
        pnorm = rr**(-4)
        a = (0.5 * ddf * rr   -   2 * slo) * rr   +   3. * val
        b = (df * rr   -   2 * val) * rr
    p2  = pnorm * ( c   +   xr1 * ( b   +   xr1 * a )  )
    dp2 = pnorm * ( b   +   xr1 * 2. * a )
    ddp2 = pnorm * 2. * a

    e   = p2 * xr2**( deg - 2 )
    de  = (xr2 * dp2   +   float( deg - 2 ) * p2 ) * xr2**( deg - 3 )
    dde = (xr2 * xr2 * ddp2 + float( 2 * ( deg - 2 ) ) * xr2 * dp2  +  float( ( deg - 2 ) * ( deg - 3 ) ) * p2 )

    return e, de, dde

n_pts = 100
x = np.linspace(0.1, 10, n_pts)

A1 = -2.75
A2 =  1.84
A3 = -0.46
A = np.array([A1, A2, A3])
farr = np.zeros( (3,n_pts) )
dec = 0.71
deg = 5
r1 = 6.2
rc = 8.5

for ind, v in enumerate(A):
    f, df, ddf = bond_integral(v, dec, x)
    ir1c = (x > r1) & (x < rc)
    p, dp, ddp = poly( x, deg, r1, rc, f[ ir1c ], df[ ir1c ], ddf[ ir1c ] )
    f[ir1c]   = f[ir1c] * p
    df[ir1c]  = df[ir1c] * dp
    ddf[ir1c] = ddf[ir1c] * ddp
    farr[ind,:] = f

fig = plt.figure()
ax = plt.add_subplot(111)
ax.set_title(' Bond integrals with polynomial tails ' )
ax.set_xlabel(' Distance (Bohr) ')
ax_set_ylabel(' Energy (Ryd) ')
ax.plot( x, farr[0], label=r'$dd\sigma$'  )
ax.plot( x, farr[1], label=r'$dd\pi$'  )
ax.plot( x, farr[2], label=r'$dd\delta$'  )
ax.legend()
ax.savefig('tbe_bond_integrals_with_polynomial_cutoffs.png')
plt.show()

    

     #+END_SRC
	
** Notes for the gamma surfaces
   - Seems like some atoms are missing in the site file when it is being read
     in to tbe.
   - This means that there are some erroneous forces that make the program
     exit.
     - Must investigate how the site file is written and see the difference
       between the expected and resultant coordinates. 


** Ti Swarm fitting. 
   - Here used fitting with uniform weights across all target quantities
     without a regularisation of the parameters.
   - It can be seen that the lattice parameters aren't as good as they could
     be. This calls for the use of weighted parameters.
   - Have now started weighted parameter search for the best parameters with
     regards to titanium. 

#+BEGIN_SRC bash
Build Objective Function
 ...with L1 norm 
| Quantity      |  predicted |     target | squared diff. |    p_norm |   weight |  objective |
|---------------+------------+------------+---------------+-----------+----------+------------|
| a_hcp:        |   4.744693 |   5.576790 |      0.692385 |  0.832097 | 1.000000 |   1.524483 |
| c_hcp:        |   7.495518 |   8.852101 |      1.840316 |  1.356583 | 1.000000 |   3.196899 |
| c_11:         | 174.924630 | 176.100000 |      1.381495 |  1.175370 | 1.000000 |   2.556865 |
| c_33:         | 190.161490 | 190.500000 |      0.114589 |  0.338510 | 1.000000 |   0.453099 |
| c_44:         |  54.517320 |  50.800000 |     13.818465 |  3.717320 | 1.000000 |  17.535784 |
| c_12:         |  65.010403 |  86.900000 |    479.154446 | 21.889597 | 1.000000 | 501.044043 |
| c_13:         |  73.335501 |  68.300000 |     25.356271 |  5.035501 | 1.000000 |  30.391772 |
| a_omega:      |   7.331279 |   8.732543 |      1.963543 |  1.401265 | 1.000000 |   3.364808 |
| c_omega:      |   4.768459 |   5.323431 |      0.307994 |  0.554972 | 1.000000 |   0.862966 |
| u_omega:      |   1.000025 |   1.000000 |      0.000000 |  0.000025 | 1.000000 |   0.000025 |
| DeltaE_O_hcp: |  -1.170318 |  -0.734754 |      0.189716 |  0.435564 | 1.000000 |   0.625281 |
| a_bcc:        |   5.331467 |   6.179489 |      0.719140 |  0.848021 | 1.000000 |   1.567162 |
| bandwidth:    |   0.325300 |   0.426000 |      0.010140 |  0.100700 | 1.000000 |   0.110840 |
Objective function: 563 

Objective Function = 563.2340263379571 
Stopping search: Swarm best position change less than 1e-08 
[ 0.34606728 -0.22330935 65.79555644 0.52284417 0. -0.62229341 1.98315066] 
563.2340263379571
#+END_SRC
   
* Useful Notes
** Org-mode 
#+BEGIN_SRC elisp
(setq org-latex-create-formula-image-program 'dvipng)
#+END_SRC

** Physics
*** Hartree-Fock
    - Hartree-Fock is a method of calculating the energy of a configuration
      with exact exchange.
    - This is done by essentially putting everything we don't know into the
      kinetic energy functional. 
    - Hamiltonian is split into contributions:
      - \[\hat{H} = \hat{T} + \hat{V}_{ \text{ext} } + \hat{G}\]
      - $\hat{G} = \hat{J} - \hat{K}$
      - $\hat{J}$ is the coulombic interaction:
      - \[ \bra{ \mathbf{r} } \hat{J} \ket{ \mathbf{n} } = \int \frac{ \bra{\mathbf{r}}\ket{n} }{|\mathbf{r} - \mathbf{r'}  |}d\mathbf{r} \]
      - So \[ E_{\text{H}} = \int \frac{\rho{\mathbf{r}\rho{\mathbf{r}'}}}{|\mathbf{r} - \mathbf{r'}|}\]
      - This includes fictitious self-interaction of electron density. 
      - The Exchange functional removes this part, thus lowering the energy

    - This method is used in Hybrid DFT. This corrects band gaps mainly. But
      there are also problems.

 
* DFT Lectures UCL 
** David Bowler O(N) DFT
*** Types of Exchange-correlation Functionals 

**** LDA
     - The electron density is the same as a uniform electron gas.
     - Exchange is Slater. 
     - Still parameterised (Ceperly). Parameters from Quantum Monte-Carlo
       calculations.

**** GGA
     - The gradient of the electron density is included in functional.
     - Have the reduced density \[ \frac{ \nabla n(\mathbf{r})}{n( \mathbf{r}
       )}\]. 
***** Perdew-Burke-Ernzerhof
      - \[ E_{\text{x}} = \int n( \mathbf{r} ) \epsilon_{\text{xc}}[n( \mathbf{r}
        )] F_{\text{x}}(S)d\mathbf{r} \]
      - \[ E_{\text{c}} = \int n[ \epsilon_{\text{c}} + H(n,S) ]d\mathbf{r} \]
      - These integrals are then fitted to various limits. 

**** Hybrid Functionals
     - These are functionals to correct the self-interaction energy that is
       apparent in the previously mentioned functionals.
     - The Hartree term \[V_{\text{H}}=\int \frac{\rho(\mathbf{r})}{|\mathbf{r} - \mathbf{r}'|} d\mathbf{r}  \]
     - The exchange term cancels the celf interaction.
     - Generally only a part of this Hartree-Fock calculation is included in
       the function otherwise it is not stable. 


 


DFT speed is limited by how it can find the energies of the system we are
interested in. 
Diagonalisation is inherently an $\mathcal{O}(N^3)$ process. 

To actually build the hamiltonian it is of $\mathcal{O}(N^2)$. 
Solving is $\mathcal{O}(N^3)$. 

How do we solve for DFT?
Generally it depends on the choice of functional we have. 
Hybrid functionals almost scale as $\mathcal{O}(N^4)$ due to the inclusion of exact
exchange interaction by Hartree-Fock. Because of this exact exchange, there
are better band gaps . 

The $\mathcal{O}(N)$ DFT generally comes because of the manipulation of sparse matrices. 
Insead of matrix multiplication being of $\mathcal{O}(N^3)$ we can have matrix
multiplication being of $\mathcal{O}(N)$. 

The reason we can essentially do $\mathcal{O}(N)$ is that in the Kohn-Sham equations, the
density is actually a local function ($n(\mathbf{r})$, not $n(\mathbf{r}-\mathbf{r}')$) 
This means that in theory we can actually have a theory which sufficiently
describes the dynamics of a given system with an electron density that is
local in space. 
In many DFT codes however, the electron density is non-local ($n(
\mathbf{r} - \mathbf{r}')$), and
this slows down the calculation. 
To actually make it $\mathcal{O}(N)$, we have to have range cutoffs for the interactions
of the atoms. This means that the hamilitonian is sparse as quite a lot of the
elements are zero such that we can use methods that involve $\mathcal{O}(N)$
multiplication. 

When it comes to Structural relaxation there are a few things that come to
mind when structures are not converging:
there is usually only one atom that has some huge force on it. 
Consider the boundary conditions. 

For faster diagonalisation of the hamiltonian matrix it may be useful to look
at methods such as Krylov-Subsapace, Lanczos and folded-spectrum methods.

** Jochen Blumberger: Molecular dynamics 
   
   - Molecular dynamics is important. (Even at 0K there is a zero point energy
     of vibration).
   - Need theory to see how atoms move

*** Born-Oppenheimer approximation 

    - Have hamiltonian that consists of interaction between:
      * nucleus-nucleus
      * nucleus-electron
      * electron-electron
    - First assumption is that we can write the eigenfunction of
      this large hamiltonian as a product state consisting of an electronic
      ground state and nuclear eigenstate.
    - Second approximation is that we are able to say, as the mass of the ion
      $M_{I} \sim 1000 m_{e}$ then we can say that the kinetic energy term of
      with regard to the nucleus positions will be small.
    - From this we can say that the action of this nuclear kinetic energy
      operator on the electronic eigenstate is small.
    - This means we can neglect the *electronic* wavefunction, and work with
      the equation \[ \hat{H}\Phi(\mathbf{R}) = E^0_{\mathbf{R}}\Phi(\mathbf{R}) \]
      - Where $E^{0}_{ \mathbf{R} }$ is the ground state energy hypersurface
        from the electronic wavefunction. We get this from DFT calculations. 
    - Even now we can only really calculate 8 degrees of freedom for the
      Nuclear wavefunction.

*** Molecular Dynamics

**** Verlet Algorithm
     - This algorithm simply uses the forward and backward derivative of the
       nuclear positions and adds them together to get a formula for the
       positon.
       - \[ \mathbf{R}_{I}(t + \delta t) = 2\mathbf{R}_{I} -
         \mathbf{R}_{I}(t - \delta t) + \frac{f_I(t)}{M_{I}}\delta t^3 \mathcal{O}(\delta t^{4})  \]
       - \[ \mathbf{\dot{R}}_{I}(t) = \frac{1}{2 \delta t} [
         \mathbf{R}_{I}(t + \delta t) - \mathbf{R}_{I}(t - \delta t) ] + \mathcal{O}(\delta t^{3})  \]
       - This causes a problem however: the velocity is calculated a step
         after that of the positons. So this leads to the Velocity Verlet
         algorithm. 

**** Velocity Verlet Algorithm
     - For this algorithm the forward derivative with respect to nuclear
       positions is used with a calculation of the force at a later time. 
     - Then the taylor expansion of the position at time t is used with the
       terms of later time.
     - \[ \mathbf{R}_{I}(t + \delta t) = \mathbf{R}_{I}(t) +
       \mathbf{\dot{R}}_{I}\delta t + \frac{f_I(t)}{M_{I}}\delta t^3 + \mathcal{O}(\delta t^{3})  \]
     - \[ \mathbf{ \dot{R} }_{I}(t + \delta t) = \mathbf{\dot{R}}_{I}(t) +  \frac{1}{2 M_{I}} [ \mathbf{f}_{I}(t + \delta t) + \mathbf{R}_{I}(t)  ] + \mathcal{O}(\delta t^{3})  \]

**** How to calculate the forces
     - Use the Hellmann-Feynman theorem.
       - $$ \mathbf{f}_{I} = < \psi^{0}_{\mathbf{R}} | \frac{\partial}{\partial   \mathbf{R}_{I}}\hat{H} |\psi^{0}_{\mathbf{R}} >   $$



* org-mode cheat sheet 
  - New TODO: M-<shift>-<ret>
  - Done TODO: C-c C-t
  - Links: [[][]] [link] then [description]
  - Open link: Move over cursor and do C-c C-o
  - Link to local files:
    * Open file (C-x C-f) then do C-c l,
    * then go back to org file and do C-c C-l (e.g. [[file:~/Documents/docs/PhDPaperSummary/upgrade_rep_plus_notes.tex::\documentclass%5B][Upgrade_report_plus_notes]])
  - To remove window in buffer C-x 0
  - Overview of document <shift>-<TAB> to condense to titles.
  - Can have global todo list
  - < s TAB expands to a ‘src’ code block.
  - < l TAB expands to:
  #+BEGIN_EXPORT latex
  #+END_EXPORT


  - If I want more help I can go to the [[https://orgmode.org/manual/][org-mode manual]]


